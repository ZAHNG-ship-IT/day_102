# 动态内存深入演示 — 讲解与备忘

本文对应源码：`动态内存深入演示.c`

## 核心结论（速记）
- 每次 `malloc(n)` 返回一块“内部连续”的内存，大小至少为 `n`，可当数组顺序访问。
- 不同 `malloc` 块彼此在堆上“无序且不连续”，地址差值没有意义，也不是限制。
- 分配器会按平台策略进行“对齐”和“桶粒度”分配，因此“实际可用大小(usable size)”≥请求值。
  - Windows 可用 `_msize(p)`，glibc 可用 `malloc_usable_size(p)`。
- 结构体节点内部字段地址连续且按类型对齐；链表节点之间不保证连续。
- 碎片化：释放的空洞可能被后续合适大小的申请重用，但是否重用由分配器决定。

## 与程序输出对应的解读
- [1] 不同大小的 `malloc`
  - 输出含：`req`(请求字节) / `usable`(可用字节) / `align8/16`(对齐情况)。
  - 现象：`usable >= req` 且地址满足 8/16 字节对齐。
- [2] 链表节点 `struct Node`
  - `sizeof(Node)` 为固定值；`n1/n2/n3` 的起始地址相互间差值有正有负，说明“堆上无序”。
  - `&n1->id / name / value / next` 连续且符合对齐，证明“节点内部连续”。
- [3] 碎片化与重用
  - 释放 `B(1024)` 后，再 `malloc(512)` 得到的 `D` 可能等于 `B` 的旧地址，体现“洞位重用”。

## 为什么“地址差”不是大小限制？
- 地址差只是两个分配块“起始位置”的距离，反映堆的当时布局；并不是你能用的空间。
- 真正能安全访问的范围由 `sizeof(结构体)` 或 `malloc` 的请求大小（加上分配器给你的 usable）决定。

## 常见坑与建议
- 永远与成对 API 使用：`malloc/calloc/realloc` + `free`，避免泄漏。
- `free(p)` 后将指针置 `NULL`，避免二次释放与野指针。
- `realloc` 失败会返回 `NULL`（原指针仍有效），使用临时变量承接：`tmp = realloc(p, n)`。
- 需要大量节点且数量已知：一次 `malloc(N*sizeof(Node))`，手工串 `next`，提升局部性与速度。
- 频繁增删节点：可考虑“空闲链表/内存池”复用已释放节点，减少碎片与系统调用。

## 可选：编译与运行（PowerShell）
```powershell
# 进入目录
cd "c:\Users\21862\Desktop\c语言_比特_study"

# 编译并运行（已在工程中验证通过）
gcc -Wall -Wextra -g3 动态内存深入演示.c -o output\动态内存深入演示.exe
./output/动态内存深入演示.exe
```

## 附：`struct Node` 布局示意
- 字段顺序：`int id` -> `char name[32]` -> `double value` -> `Node* next`
- 在 64 位平台，指针与 `double` 常为 8 字节，结构体整体按最大对齐；实际 `sizeof(Node)` 以编译器结果为准。

---
更新日期：2025-08-28  来源：`动态内存深入演示.c` 运行与分析

## FAQ：未释放的堆内存会怎样？

- 进程未结束：如果你 `malloc` 了内存但丢失了指针（无法 `free`），这叫“内存泄漏”。
  - 后果：这块内存对本进程来说一直占用，无法再利用，长时间运行会越占越多，导致性能下降或最终分配失败（崩溃/退出）。
- 进程结束：现代 OS（Windows/Linux/macOS）会在进程退出时回收它占用的所有资源（包括堆内存、句柄等）。
  - 结论：内存不会在系统层面“永久泄漏”。但这并不能成为不写 `free` 的理由。

什么时候必须严肃处理泄漏？
- 长期运行的程序/服务/游戏/守护进程：不释放就会持续涨内存，影响稳定性。
- 循环里频繁分配：若无对称 `free`，内存会线性或更快增长。

实践建议
- 形成“不拥有就不释放、拥有就负责释放”的所有权约定（谁 `malloc` 谁 `free`，或明确移交）。
- `free(p)` 后设 `p = NULL`，避免二次释放/野指针。
- 对复杂结构（树/图/链表），写专门的 `destroy_*` 递归/迭代释放函数，统一收口。
- 在Windows可用“诊断工具/性能分析器”，在Linux可用`valgrind`检查泄漏。
